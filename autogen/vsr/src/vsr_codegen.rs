use crate::vsr_metadata::vsr_type;
use std::any::TypeId;

fn type_id_to_c(id: TypeId) -> &'static str {
    if id == TypeId::of::<u8>() { "uint8_t" }
    else if id == TypeId::of::<i8>() { "int8_t" }
    else if id == TypeId::of::<u16>() { "uint16_t" }
    else if id == TypeId::of::<i16>() { "int16_t" }
    else if id == TypeId::of::<u32>() { "uint32_t" }
    else if id == TypeId::of::<i32>() { "int32_t" }
    else if id == TypeId::of::<f32>() { "float" }
    else if id == TypeId::of::<u64>() { "uint64_t" }
    else if id == TypeId::of::<i64>() { "int64_t" }
    else if id == TypeId::of::<f64>() { "double" }
    else if id == TypeId::of::<bool>() { "bool" }
    else { "void" }
}

pub fn generate_c(vsr_metadata: &vsr_type) -> (String, String) {
    // --- Pre-calculate dynamic sections ---

    // 1. Subtype Struct Definitions (Header)
    let subtype_defs: String = vsr_metadata.subtypes.iter().map(|subtype| {
        let fields = subtype.fields.iter().map(|&(name, type_id, units, desc)| {
            let c_type = type_id_to_c(type_id);
            let unit_str = if units.is_empty() { String::new() } else { format!(" ({})", units) };
            format!("    {} {}; // {}{}", c_type, name, desc, unit_str)
        }).collect::<Vec<_>>().join("\n");

        format!("typedef struct __attribute__((packed)) {{\n{}\n}} {}_t;", fields, subtype.name)
    }).collect::<Vec<_>>().join("\n\n");

    // 2. Main Struct Fields (Header)
    let main_struct_fields: String = vsr_metadata.subtypes.iter().map(|subtype| {
        format!(
            "    SemaphoreHandle_t {name}_mutex;\n    int64_t {name}_timestamp;\n    {name}_t {name};",
            name = subtype.name
        )
    }).collect::<Vec<_>>().join("\n\n");
    
    let main_struct_def = format!("typedef struct {{\n{}\n}} vehicle_status_reg_s;", main_struct_fields);

    // 3. Init Logic (Source)
    let init_logic: String = vsr_metadata.subtypes.iter().map(|subtype| {
        format!(
            "    static StaticSemaphore_t {name}_mutex_buf;\n    vsr->{name}_mutex = xSemaphoreCreateMutexStatic(&{name}_mutex_buf);",
            name = subtype.name
        )
    }).collect::<Vec<_>>().join("\n");

    // 4. Pack Logic (Source)
    let pack_logic: String = vsr_metadata.subtypes.iter().map(|subtype| {
        format!(
            "    xSemaphoreTake(vsr->{name}_mutex, portMAX_DELAY);\n    memcpy(buffer + offset, (void*)&vsr->{name}, sizeof({name}_t));\n    xSemaphoreGive(vsr->{name}_mutex);\n    offset += sizeof({name}_t);\n",
            name = subtype.name
        )
    }).collect::<Vec<_>>().join("\n");


    // --- Assemble final strings using templates ---

    let h_out = format!(
r#"// This file is automatically generated by vsr_codegen.rs
// Do not edit manually.

#ifndef VSR_AUTOGEN_H
#define VSR_AUTOGEN_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"
#include "esp_timer.h"

// Acquire and release a vsr subregister semaphore
#define ACQ_REL_VSRSEM_W(mutating_element, body)                  \
    xSemaphoreTake(vsr->mutating_element##_mutex, portMAX_DELAY); \
    vsr->mutating_element##_timestamp = esp_timer_get_time();     \
    body xSemaphoreGive(vsr->mutating_element##_mutex);

#define ACQ_REL_VSRSEM_R(mutating_element, body)                  \
    xSemaphoreTake(vsr->mutating_element##_mutex, portMAX_DELAY); \
    body xSemaphoreGive(vsr->mutating_element##_mutex);

{subtype_defs}

// Backward Compatibility
typedef motor_power_t motor_mspeed_status_s;
typedef motor_speed_t motor_hspeed_status_s;
typedef motor_safety_t motor_safety_status_s;
typedef motor_control_t motor_control_s;
typedef motor_error_t motor_error_state;
typedef pedal_t pedal_s;
typedef motor_prot1_t motor_protections_1_s;
typedef motor_prot2_t motor_protections_2_s;

{main_struct_def}

extern volatile vehicle_status_reg_s vehicle_status_register;

int vsr_init(vehicle_status_reg_s* vsr);
size_t vsr_pack(vehicle_status_reg_s* vsr, uint8_t* buffer);

#endif // VSR_AUTOGEN_H
"#, 
        subtype_defs = subtype_defs, 
        main_struct_def = main_struct_def
    );

    let c_out = format!(
r##"#include "vsr.h"
#include <string.h>
#include "esp_timer.h"

volatile vehicle_status_reg_s vehicle_status_register = {{0}};

int vsr_init(vehicle_status_reg_s* vsr) {{
    if (vsr == NULL) return -1;
    memset((void*)vsr, 0, sizeof(vehicle_status_reg_s));

{init_logic}

    return 0;
}}

size_t vsr_pack(vehicle_status_reg_s* vsr, uint8_t* buffer) {{
    if (vsr == NULL || buffer == NULL) return 0;
    size_t offset = 0;

{pack_logic}
    return offset;
}}
"##, 
        init_logic = init_logic, 
        pack_logic = pack_logic
    );

    (h_out, c_out)
}
